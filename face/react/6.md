1. **React.memo**：
   - React.memo是一个高阶组件，用于对React组件进行记忆化（memoization）。记忆化是一种性能优化技术，它存储了之前的结果，当以相同的参数再次调用时，直接返回之前存储的结果，从而避免重复计算或渲染。在React中，当组件的props没有变化时，使用React.memo可以防止组件的不必要重渲染。

2. **useMemo**：
   - useMemo是一个React Hook，它用于在组件渲染过程中缓存计算结果。它接受一个函数和一个依赖项数组作为参数。当依赖项数组中的任何一个值发生变化时，useMemo会重新执行函数并返回新的结果。否则，它会返回之前缓存的结果。这有助于避免在每次渲染时都进行昂贵的计算，从而提高性能。

3. **useCallback**：
   - useCallback也是一个React Hook，它用于缓存回调函数。当依赖项没有发生变化时，useCallback会返回缓存的回调函数，以避免不必要的函数重新创建和渲染。这有助于减少不必要的渲染和性能开销，特别是在回调函数作为props传递给子组件时。

**区别总结**：

* **优化对象**：React.memo针对的是整个组件的渲染，而useMemo和useCallback则分别针对计算结果和回调函数进行优化。
* **使用场景**：React.memo通常用于避免不必要的组件重渲染；useMemo则适用于缓存计算结果，以减少不必要的计算和渲染；useCallback则常用于优化回调函数，避免在每次渲染时都创建新的函数实例。
* **返回值**：React.memo返回一个新的、记忆化的组件；useMemo返回缓存的计算结果；useCallback返回缓存的回调函数。

在实际开发中，应根据具体需求和场景选择合适的工具来优化React应用的性能。例如，如果某个子组件的渲染成本很高，并且其props在父组件重新渲染时保持不变，那么可以使用React.memo来避免不必要的子组件重渲染。如果某个计算结果需要被多次使用，并且其依赖项在组件渲染过程中不会频繁变化，那么可以使用useMemo来缓存该计算结果。而如果需要将一个回调函数作为props传递给子组件，并且该回调函数在父组件重新渲染时应该保持不变，那么可以使用useCallback来缓存该回调函数。

但它们也存在一些潜在的缺点和注意事项：

**React.memo的缺点：**

1. **性能问题**：虽然React.memo可以避免不必要的组件重渲染，但如果组件的props变化频繁，或者组件本身的渲染成本较低，使用React.memo可能会引入额外的性能开销，因为每次props变化时都需要进行浅比较。

2. **浅比较限制**：React.memo默认使用浅比较来检查props是否发生变化。这意味着如果props是复杂对象或数组，并且其内部值发生了变化，但引用没有变化，React.memo可能无法正确检测到这些变化，从而导致组件状态不一致的问题。

**useMemo的缺点：**

1. **过度优化**：如果过度使用useMemo，可能会引入不必要的复杂性，并导致性能下降而不是提升。特别是对于计算成本较低或依赖项频繁变化的情况，使用useMemo可能并不划算。

2. **依赖项管理**：useMemo要求提供一个依赖项数组，用于指定何时重新计算缓存的值。如果依赖项没有正确设置，可能会导致缓存的值在需要更新时没有被更新，或者在不需要更新时却被重新计算。

**useCallback的缺点：**

1. **滥用问题**：有时开发者可能会滥用useCallback，试图在每次父组件渲染时都保持子组件的props不变。然而，如果回调函数本身并不依赖于父组件的渲染状态，或者子组件能够正确处理新的回调函数实例，那么使用useCallback可能是不必要的，并可能引入额外的复杂性和性能开销。

2. **缓存失效**：与useMemo类似，useCallback也依赖于依赖项数组来确定何时重新创建回调函数。如果依赖项没有正确设置，可能会导致回调函数在需要更新时没有被更新，或者在不需要更新时却被重新创建。

**总结**：

这些特性在React中都有其用途，但使用时需要谨慎。开发者应该根据具体的应用场景和需求来评估是否需要使用它们，并确保正确设置依赖项以避免潜在的问题。同时，过度优化也应该避免，因为有时简单的解决方案可能更加高效和可靠。

当props是复杂对象或数组，并且其内部值发生了变化但引用没有变化时，React.memo确实可能无法正确检测到这些变化。这是因为React.memo默认使用浅比较（shallow comparison）来检查props是否相等。浅比较只会比较对象的引用（即内存地址），而不会深入比较对象的内部值。

为了处理这种情况，你有几个选项：

1. **避免使用复杂对象或数组作为props**：尽可能使用简单的数据类型（如字符串、数字、布尔值）或不可变数据结构作为props。这样可以确保当数据变化时，引用也会变化，从而触发React.memo的比较。

2. **使用自定义比较函数**：React.memo接受一个可选的比较函数作为第二个参数。你可以提供自己的比较逻辑来深入比较对象的内部值。这样，即使引用没有变化，只要内部值发生了变化，React.memo也能正确检测到并重新渲染组件。

   ```jsx
   function areEqual(prevProps, nextProps) {
     // 在这里实现你的比较逻辑
     // 例如，使用深度比较库来比较prevProps和nextProps
     return deepCompare(prevProps, nextProps);
   }

   const MyComponent = React.memo(MyComponentBase, areEqual);
   ```

3. **使用不可变数据结构**：使用不可变数据结构库（如Immutable.js或Immer）来管理你的状态和数据。这些库提供了方法来创建新的数据副本而不是修改现有数据，从而确保当数据变化时引用也会变化。

4. **考虑是否真的需要React.memo**：在某些情况下，即使props内部值发生了变化，但如果组件能够正确处理这些变化并且没有明显的性能问题，那么可能并不需要使用React.memo。过度使用优化技术可能会增加代码的复杂性并引入不必要的开销。

5. **使用forceUpdate**：作为最后的手段，如果其他方法都不适用，你可以考虑使用`forceUpdate`方法来强制组件重新渲染。然而，这通常不是一个好的做法，因为它破坏了React的声明式编程模型，并可能导致难以追踪的bug和性能问题。

综上所述，处理复杂对象或数组作为props时，最佳实践是尽量避免使用它们作为props，或者实现自定义的比较逻辑来确保正确的比较。同时，也要仔细评估是否真的需要React.memo来优化你的组件。