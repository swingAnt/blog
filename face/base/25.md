1. **原型链继承**

这是JavaScript中最基本的继承方式，利用原型链实现。但这种方式存在一个主要问题，那就是所有的实例对象都会共享一份原型，如果修改了原型上的属性，那么所有的实例对象的这个属性都会被修改。


```javascript
function Parent() {
    this.name = 'parent';
}

function Child() {
    this.type = 'child';
}

Child.prototype = new Parent();
```
2. **借用构造函数（经典继承）**

为了解决原型链继承中的问题，可以使用借用构造函数的方式。但这种方式也存在一个问题，就是方法都在构造函数中定义，因此函数复用就无从谈起了，并且，在超类型原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。


```javascript
function Parent() {
    this.name = 'parent';
    this.play = [1, 2, 3];
}

function Child() {
    Parent.call(this);
    this.type = 'child';
}
```
3. **组合继承**

结合原型链继承和构造函数继承，可以充分利用两者之间的优势，避免它们的缺点。这是目前使用最广泛的继承方式。


```javascript
function Parent() {
    this.name = 'parent';
    this.play = [1, 2, 3];
}

function Child() {
    Parent.call(this);
    this.type = 'child';
}

Child.prototype = new Parent();
Child.prototype.constructor = Child;
```
4. **拷贝继承**

拷贝继承的思想很简单，就是把父对象的所有属性和方法，拷贝进子对象。这种方式比较直观，但效率较低。

**ES6继承方式**

在ES6中，引入了`class`关键字，使得继承的写法更加清晰和易于理解。

1. **ES6的class继承**

ES6通过`class`关键字定义类，通过`extends`关键字实现继承。这种方式更加接近传统面向对象的写法。


```javascript
class Parent {
    constructor() {
        this.name = 'parent';
    }

    play() {
        console.log(this.name + ' is playing.');
    }
}

class Child extends Parent {
    constructor() {
        super(); // 调用父类的constructor
        this.type = 'child';
    }
}
```
注意，在子类的构造函数中，必须调用`super()`方法，否则新建实例时会报错。这是因为子类自己的`this`对象，必须先通过`super()`方法，从父类那里继承下来。

ES6的class继承实质上是基于原型链的，只是语法上做了封装，使得写法更加清晰、易读。